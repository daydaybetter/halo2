### Circuit trait

```rust
    type Config: Clone;
    type FloorPlanner: FloorPlanner;
    fn without_witnesses(&self) -> Self;
    fn configure(meta: &mut ConstraintSystem<F>) -> Self::Config;
    fn synthesize(&self, config: Self::Config, layouter: impl Layouter<F>) -> Result<(), Error>;
```

* Config
    定义电路的约束，主要是create_gate()函数来定义。
* FloorPlanner
    电路的floor planing策略，实现synthesize()函数，使用提供的Config、constants、以及Assignment来synthesize电路。
* without_witnesses
    没有witness的电路，一般使用Self::default()。
* configure
    电路门的描述创建，约束的构建。
* synthesize
    根据提供的config，来对Layouter进行赋值，核心用到了它的assin_region()函数，而这个函数用到了closure，它的参数是Region。

halo2的电路开发，核心是两个函数：configure和synthesize，前者创建门定义约束，后者将witness和public数据赋值到约束中。

### Chip trait

```rust
    type Config: fmt::Debug + Clone;
    type Loaded: fmt::Debug + Clone;
    fn config(&self) -> &Self::Config;
    fn loaded(&self) -> &Self::Loaded;
```

### Instructions trait

```rust
    type Num;
    fn load_private(&self, layouter: impl Layouter<F>, a: Value<F>) -> Result<Self::Num, Error>;
    fn load_constant(&self, layouter: impl Layouter<F>, constant: F) -> Result<Self::Num, Error>;
    fn mul(&self, layouter: impl Layouter<F>, a: Self::Num, b: Self::Num) -> Result<Self::Num, Error>;
    fn expose_public(&self, layouter: impl Layouter<F>, num: Self::Num, row: usize) -> Result<(), Error>;
```

### Circuit implementation

```rust
    type Config = FieldConfig;
    type FloorPlanner = SimpleFloorPlanner;
    fn without_witnesses(&self) -> Self { ... }
    fn configure(meta: &mut ConstraintSystem<F>) -> Self::Config { ... }
    fn synthesize(&self, config: Self::Config, mut layouter: impl Layouter<F>) -> Result<(), Error> { ... }
```

以simple-example为例：

在定义电路时，会修改`ConstraintSystem`，且返回`Config`。

```rust
// MyCircuit::configure
fn configure(meta: &mut ConstraintSystem<F>) -> Self::Config {
    // 创建两个advice列，作为FieldChip的输入。
    let advice = [meta.advice_column(), meta.advice_column()];

    // 还需要一个instance列来存储公开输入。
    let instance = meta.instance_column();

    // 创建一个fixed列来加载常数
    let constant = meta.fixed_column();

    FieldChip::configure(meta, advice, instance, constant)
}

// FieldChip::configure
fn configure(
    meta: &mut ConstraintSystem<F>,
    advice: [Column<Advice>; 2],
    instance: Column<Instance>,
    constant: Column<Fixed>,
) -> <Self as Chip<F>>::Config {
    meta.enable_equality(instance); // 传入参数的相等性检查
    meta.enable_constant(constant);
    for column in &advice {
        meta.enable_equality(*column);
    }
    let s_mul = meta.selector();

    // 定义乘法门
    meta.create_gate("mul", |meta| {
        // 需要3个advice cells和1个selector cell来实现乘法
        // 把他们按下表来排列：
        // | a0  | a1  | s_mul |
        // |-----|-----|-------|
        // | lhs | rhs | s_mul |
        // | out |     |       |
        // 门可以用任何相对偏移，但每一个不同的偏移都会对证明增加开销。
        // 最常见的偏移值是 0 (当前行), 1(下一行), -1(上一行)。
        // 针对这三种情况，有特定的构造函数来构造`Rotation`结构。
        let lhs = meta.query_advice(advice[0], Rotation::cur());
        let rhs = meta.query_advice(advice[1], Rotation::cur());
        let out = meta.query_advice(advice[0], Rotation::next());
        let s_mul = meta.query_selector(s_mul);

        // 最终，将约束门的多项式表达式返回。
        // 对于乘法门，仅需要一个多项式约束。
        //
        // `create_gate`函数返回的多项式表达式，在证明系统中一定等于0。
        // 我们的表达式有以下性质：
        // - 当s_mul = 0时，lhs、rhs、out可以是任意值。
        // - 当s_mul != 0时，lhs、rhs、out将满足lhs * rhs = out这条约束。
        vec![s_mul * (lhs * rhs - out)]
    });

    FieldConfig {
        advice,
        instance,
        s_mul,
    }
}
```

实际上`configure`主要做的就是生成约束关系，它做了以下事情：

1. 创建advice，instance以及fixed column。advice_column()，instance_column()和fixed_column()的功能类似，都是创建一个相应类型（advice/instance/fixed）的cloumn，将ConstraintSystem中对应column的计数加1，再将这个新建的column返回出来。
2. 调用ConstraintSystem的enable_equality()函数，放入instance和advice column；调用ConstraintSystem的enable_constant()放入constant。而这两个函数的作用是Enable the ability to enforce equality over cells in this column（传入参数的相等性检查）。
3. 调用selector函数，生成selector。
4. 调用ConstraintSystem的create_gate函数，传入以&mut VirtualCells为参数的closure，创建gate。在这个closure中，调用了VirtualCells的query_advice函数，传入生成的advice column，使用column和rotation构造Expression；调用了VirtualCells的query_selector函数，传入生成的selector构造Expression；最后返回以Expression为主的约束。注意，query_advice()函数，既生成了Expression，又将 column和rotation放入ConstraintSystem中，这样将Expression和ConstraintSystem通过column和rotation联系起来。create_gate函数就是将closure里生成的约束和Expression，构造Gate，并存入ConstraintSystem的gates数组里。
5. 最后返回Config。

```rust
// examples/simple-example.rs MyCircuit::synthesize
fn synthesize(
    &self,
    config: Self::Config,
    mut layouter: impl Layouter<F>,
) -> Result<(), Error> {
    let field_chip = FieldChip::<F>::construct(config);

    // 将我们的隐私值加载到电路中。
    let a = field_chip.load_private(layouter.namespace(|| "load a"), self.a)?;
    let b = field_chip.load_private(layouter.namespace(|| "load b"), self.b)?;

    // 将常数因子加载到电路中。
    let constant =
        field_chip.load_constant(layouter.namespace(|| "load constant"), self.constant)?;

    // 我们只能使用简单的乘法。我们可以将我们的电路实现为：
    //     asq  = a*a
    //     bsq  = b*b
    //     absq = asq*bsq
    //     c    = constant*asq*bsq
    //
    // 但按以下实现更为高效：
    //     ab   = a*b
    //     absq = ab^2
    //     c    = constant*absq
    let ab = field_chip.mul(layouter.namespace(|| "a * b"), a, b)?;
    let absq = field_chip.mul(layouter.namespace(|| "ab * ab"), ab.clone(), ab)?;
    let c = field_chip.mul(layouter.namespace(|| "constant * absq"), constant, absq)?;

    // 将结果公开为电路的公开输入。
    field_chip.expose_public(layouter.namespace(|| "expose c"), c, 0)
}

// examples/simple-example.rs FieldChip::load_private
fn load_private(
    &self,
    mut layouter: impl Layouter<F>,
    value: Value<F>,
) -> Result<Self::Num, Error> {
    let config = self.config();

    layouter.assign_region(
        || "load private",
        |mut region| {
            region
                .assign_advice(|| "private input", config.advice[0], 0, || value)
                .map(Number)
        },
    )
}
// examples/simple-example.rs FieldChip::load_constant
fn load_constant(
    &self,
    mut layouter: impl Layouter<F>,
    constant: F,
) -> Result<Self::Num, Error> {
    let config = self.config();

    layouter.assign_region(
        || "load constant",
        |mut region| {
            region
                .assign_advice_from_constant(|| "constant value", config.advice[0], 0, constant)
                .map(Number)
        },
    )
}
// examples/simple-example.rs FieldChip::expose_public
fn expose_public(
    &self,
    mut layouter: impl Layouter<F>,
    num: Self::Num,
    row: usize,
) -> Result<(), Error> {
    let config = self.config();

    layouter.constrain_instance(num.0.cell(), config.instance, row)
}
```

assign_region和constrain_instance是Layouter trait的函数。

```rust
pub trait Layouter<F: Field> {
    /// Represents the type of the "root" of this layouter, so that nested namespaces
    /// can minimize indirection.
    type Root: Layouter<F>;

    /// Assign a region of gates to an absolute row number.
    ///
    /// Inside the closure, the chip may freely use relative offsets; the `Layouter` will
    /// treat these assignments as a single "region" within the circuit. Outside this
    /// closure, the `Layouter` is allowed to optimise as it sees fit.
    ///
    /// ```ignore
    /// fn assign_region(&mut self, || "region name", |region| {
    ///     let config = chip.config();
    ///     region.assign_advice(config.a, offset, || { Some(value)});
    /// });
    /// ```
    /// 将门区域分配给绝对行号。
    /// 在封闭内部，芯片可以自由使用相对偏移量； `Layouter` 会将这些分配视为电路中的单个“区域”。在这个闭包之外，Layouter 可以根据需要进行优化。
    fn assign_region<A, AR, N, NR>(&mut self, name: N, assignment: A) -> Result<AR, Error>
    where
        A: FnMut(Region<'_, F>) -> Result<AR, Error>,
        N: Fn() -> NR,
        NR: Into<String>;

    #[cfg(feature = "parallel_syn")]
    fn assign_regions<A, AR, N, NR>(
        &mut self,
        name: N,
        assignments: Vec<A>,
    ) -> Result<Vec<AR>, Error>
    where
        A: FnMut(Region<'_, F>) -> Result<AR, Error> + Send,
        AR: Send,
        N: Fn() -> NR,
        NR: Into<String>;

    /// Assign a table region to an absolute row number.
    ///
    /// ```ignore
    /// fn assign_table(&mut self, || "table name", |table| {
    ///     let config = chip.config();
    ///     table.assign_fixed(config.a, offset, || { Some(value)});
    /// });
    /// ```
    fn assign_table<A, N, NR>(&mut self, name: N, assignment: A) -> Result<(), Error>
    where
        A: FnMut(Table<'_, F>) -> Result<(), Error>,
        N: Fn() -> NR,
        NR: Into<String>;

    /// 将[`Cell`]约束为等于绝对位置下instance column的行值。
    fn constrain_instance(
        &mut self,
        cell: Cell,
        column: Column<Instance>,
        row: usize,
    ) -> Result<(), Error>;

    /// Queries the value of the given challenge.
    ///
    /// Returns `Value::unknown()` if the current synthesis phase is before the challenge can be queried.
    fn get_challenge(&self, challenge: Challenge) -> Value<F>;

    /// Gets the "root" of this assignment, bypassing the namespacing.
    ///
    /// Not intended for downstream consumption; use [`Layouter::namespace`] instead.
    fn get_root(&mut self) -> &mut Self::Root;

    /// Creates a new (sub)namespace and enters into it.
    ///
    /// Not intended for downstream consumption; use [`Layouter::namespace`] instead.
    fn push_namespace<NR, N>(&mut self, name_fn: N)
    where
        NR: Into<String>,
        N: FnOnce() -> NR;

    /// Exits out of the existing namespace.
    ///
    /// Not intended for downstream consumption; use [`Layouter::namespace`] instead.
    fn pop_namespace(&mut self, gadget_name: Option<String>);

    /// Enters into a namespace.
    fn namespace<NR, N>(&mut self, name_fn: N) -> NamespacedLayouter<'_, F, Self::Root>
    where
        NR: Into<String>,
        N: FnOnce() -> NR,
    {
        self.get_root().push_namespace(name_fn);

        NamespacedLayouter(self.get_root(), PhantomData)
    }
}
```

get_root、namespace、push_namespace、pop_namespace函数，都是涉及到namespace，用于标识当前Layouter。constrain_instance函数用于对某个Cell和绝对位置下instance column的行值进行约束。最核心的函数是assign_region和assign_table，分别用于region和table的赋值，是这个trait最重要的功能。assign_region函数接收一个string和FnMut(Region<'_, F>) -> Result<AR, Error>的closure，且含有&mut self。我们看看这个重要的Region的定义：

pub struct Region<'r, F: Field> {
    region: &'r mut dyn layouter::RegionLayouter<F>, 
}
可知 Region 是对 RegionLayouter 的封装，而 RegionLayouter 是一个用于 Region 的Layouter，在介绍 RegionLayouter 之前，我们要避免深入细节太多，我们先看看Layouter的具体实现。simple-example这个例子里，SingleChipLayouter实现了Layouter的trait。


### Chip implementation

```rust
    type Config = FieldConfig;
    
    fn load_private(&self, mut layouter: impl Layouter<F>, value: Value<F>) -> Result<Self::Num, Error> { ... }
    fn load_constant(&self, mut layouter: impl Layouter<F>, constant: F) -> Result<Self::Num, Error> { ... }
    fn mul(&self, mut layouter: impl Layouter<F>, a: Self::Num, b: Self::Num) -> Result<Self::Num, Error> { ... }
    fn expose_public(&self, mut layouter: impl Layouter<F>, num: Self::Num, row: usize) -> Result<(), Error> { ... }
```

### ChipConfig

```rust
    advice: [Column<Advice>; 2],
    instance: Column<Instance>,
    s_mul: Selector,
```
